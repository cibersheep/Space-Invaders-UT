/////////////////////////////////
/// Space InVectors © 2012 Mike Panter & Alchemise Limited (http://alchemise.net). 
/// All rights reserved. For educational use only.
/// 
/// LICENSE: Redistributions may not be sold or used in any commercial product or activity.
/// LEGAL: ANY EXPRESS OR IMPLIED WARRANTIES ARE DISCLAIMED.
///
/// Inspired by:
///      "Space Invaders" by Tomohiro Nishikado (Taito 1978)
///         (http://en.wikipedia.org/wiki/Tomohiro_Nishikado)
///      "SVG-oids" by Microsoft's Andy Zeigler 
///         (http://ie.microsoft.com/testdrive/Graphics/SVGoids/Default.xhtml)
///
////////

/*global Modernizr, $SVG, $DOM */
/*jslint sloppy: true, white: true, browser: true, windows: false, laxbreak: false */
/*jshint forin:true, noarg:true, noempty:true, eqeqeq:true, strict:true, undef:true, unused:true, browser:true, jquery:true, indent:4, maxerr:50, white:false, wsh:false, laxbreak:true, newcap:true */
(function () {
    "use strict";

    // SVG
    var svgns = "http://www.w3.org/2000/svg";       // SVG Namespace
    var xlinkns = "http://www.w3.org/1999/xlink";   // XLink Namespace
    var svgDocument;                                // Global SVG doc
    var titleSvgDocument;                           // Title SVG doc
    var backSvgDocument;                            // Background SVG doc
    var store;                                      // Data Store
    var state;                                      // Game State
    var view;                                       // Window Positions
    var titleScreen;
    var soundEnabled = false;                       // To prevent Safari crashing when QuickTime is missing.
    var isFrameSkip;                                // Used to skip frames

    // Touch Controls
    var pauseButton;
    var playButton;
    var joystick;
    var fireButton;
    var muteButton;

    // TODO: move to classes
    var touchCanvas;
    var svgOffsetX, canvasWidth, canvasHeight;
    var pointerDown = {};

    // Timers
    var mainLoopTimer = 0;
    var fpsTimer = 0;
    var frameInterval = 100.0 / 3; // 30FPS
    var framesPerSecond;
    var resizeTimer;

    // FPS Counter
    var frameCount = 0;
    var lastFPSUpdateTime = 0;
    var showFPS = false;
    var fpsText;

    // Keystate
    var keyLeftPressed = false;
    var keyRightPressed = false;
    var keyShootPressed = false;
    var keyPausePressed = false;
    var keyMutePressed = false;

    // Objects/States
    var gun;
    var bullet;
    var invaders;
    var scoring;
    var lives;
    var ufo;
    var gameOverMessage;
    var background;
    var mute;
    var bomb;
    var missile;  // Same as a bomb.
    var barriers;
    var marching;

    // Invader Levels: 120, 144, 160, 168, 176
    var invaderY;
    var invaderElemArray;
    var invaderFill = ["#F0F", "#0FF", "#0F0", "#FF0", "#F00"];

    // Bomb/Missile Sprites
    var bombGroupElement;   // global for appending bombs.

    var BombPath = [
        "M2,0v1h1v-1h-1zm0,1h-1v1h1v-1zm-1,1h-1v1h1v-1zm0,1v1h1v-1h-1zm1,1v1h1v-1h-1zm0,1h-1v1h1v-1zm-1,1h-1v1h1v-1z",
        "M1,0v1h1v-1h-1zm0,1h-1v1h1v-1zm0,1v1h1v-1h-1zm1,1v1h1v-1h-1zm0,1h-1v1h1v-1zm-1,1h-1v1h1v-1zm0,1v1h1v-1h-1z",
        "M0,0v1h1v-1h-1zm1,1v1h1v-1h-1zm1,1v1h1v-1h-1zm0,1h-1v1h1v-1zm-1,1h-1v1h1v-1zm0,1v1h1v-1h-1zm1,1v1h1v-1h-1z",
        "M1,0,1,1,2,1,2,0,1,0zm1,1,0,1,1,0,0-1-1,0zm0,1-1,0,0,1,1,0,0-1zm-1,1-1,0,0,1,1,0,0-1zm0,1,0,1,1,0,0-1-1,0zm1,1,0,1,1,0,0-1-1,0zm0,1-1,0,0,1,1,0,0-1z"
    ];

    var MissilePath = [
        "M0,0v1h1v6h1v-6h1v-1h-3z",
        "M1,0v2h-1v1h1v4h1v-4h1v-1h-1v-2h-1z",
        "M1,0v4h-1v1h1v2h1v-2h1v-1h-1v-4h-1z",
        "M1,0v6h-1v1h1,1,1v-1h-1v-6h-1z"
    ];

    var BombExplodeBottomPath = "M2,1v1h1v-1h-1zm-2,1v1h1v-1h-1zm4,0v1h1v-1h-1zm1,1v1h1v-1h-1zm0,1h-1v-1h-2v1h-1v1h1v1h-1v1h1v1h3v-1h1v-1h-1v-2zm-4,3h-1v1h1v-1zm0-1v-1h-1v1h1z";
    var BombExplodePath = "M2,2v1h1v-1h-1zm1,1v1h-1v1h-1v1h1v1h1v1h1v-1h1v-1h1v-1h-1v-1-1h-1-1zm2,0h1v-1h-1v1zm0,4v1h1v-1h-1zm-3,0h-1v1h1v-1zm-1,0v-1h-1v1h1zm0-2v-1h-1v1h1zm0-1h1v-1h-1v1z";

    var availableBombs = [];

    var bulletExplodeElement;

    ///// 
    ////  Helper Class - shorthand
    ///
    function Helper() {
        this.pointy = ((navigator.msMaxTouchPoints && (navigator.msMaxTouchPoints > 1)) === true);
        this.touch = Modernizr.touch || this.pointy;
    }

    Helper.prototype = {
        DOM: function (id) { return document.getElementById(id); },
        SVG: function (id) { return svgDocument.getElementById(id); }
    };

    var helper = new Helper();

    ///// 
    ////  Store Class - Handles local storage
    ///
    function Store() {
        this.useLocalStorage = Modernizr.localstorage;
        if (this.useLocalStorage) {
            this.storage = window.localStorage;
        }
        else {
            this.mute = "false";
            
            this.highScore = "0";
        }
    }

    Store.prototype = {
        set: function (key, value) {
            if (this.useLocalStorage) {
                this.storage.setItem(key, JSON.stringify(value));
            }
            else {
                switch (key) {
                    case "mute":
                        this.mute = JSON.stringify(value);
                        break;
                    case "background":
                        this.background = JSON.stringify(value);
                        break;
                    case "highScore":
                        this.highScore = JSON.stringify(value);
                        break;
                }
            }
        },
        get: function (key) {
            if (this.useLocalStorage) {
                return JSON.parse(this.storage.getItem(key));
            }
            switch (key) {
                case "mute":
                    return JSON.parse(this.mute);
                
                case "highScore":
                    return JSON.parse(this.highScore);
                default:
                    return null;
            }
        }
    };

    ///// 
    ////  Mute Class - Handles toggling and persistence
    ///
    function Mute() {
        this.muteIcon = $SVG("muteIcon");

        if (store.get("mute") === null) {
            store.set("mute", false);
        }

        this.muteAllElements(store.get("mute"));
    }

    Mute.prototype = {
        muteAllElements: function (muted) {
            if (muted) {
                this.muteIcon.attributes.display.value = "inline";
            }
            else {
                this.muteIcon.attributes.display.value = "none";
            }
            if (soundEnabled) {
                ufo.ufoAudioElement.muted = muted;
                ufo.ufoDeadAudio.muted = muted;
                lives.extraLifeAudio.muted = muted;
                invaders.invaderArray[0].deadAlienAudio.muted = muted;
                gun.deadAudio.muted = muted;
                bullet.audioElm.muted = muted;
                for (var i = 0; i < marching.audioElements.length; i++) {
                    marching.audioElements[i].muted = muted;
                }
            }
        },
        toggle: function () {
            store.set("mute", !store.get("mute"));
            this.muteAllElements(store.get("mute"));
        }
    };

    ///// 
    ////  Background Class
    ///
    function Background() {
        this.backgroundElement = backSvgDocument.getElementById("background");
        this.blackElement = backSvgDocument.getElementById("black");
        if (store.get("background") === null) {
            store.set("background", false);
        }

    }

    Background.prototype = {
        toggle: function () {
            store.set("background", !store.get("background"));
            if (store.get("background")) {
                this.backgroundElement.attributes.display.value = "inline";
            }
 
        }
    };

    ///
    ////  END Background Class
    /////


    ///// 
    ////  Ufo Class
    ///
    function Ufo() {

        // Properties
        this.active = false;
        this.countdown = (Math.floor(Math.random() * 32) + 8) * 60; //  average = 24secs +/- 16 secs
        this.direction = -1;
        this.ufoElement = $SVG("ufo");
        this.ufoScoreGroup = $SVG("ufoScore");
        this.ufoScoreGroupMatrix = this.ufoScoreGroup.transform.baseVal.getItem(0).matrix;
        this.ufoAudioElement = $DOM("ufoAudio");
        if (typeof this.ufoAudioElement.loop !== "undefined")
            this.ufoAudioElement.loop = true;
        this.ufoDeadAudio = $DOM("ufoDeadAudio");
        this.digitElements = this.ufoScoreGroup.getElementsByTagName("use");
        this.x = 198;
        this.ufoElement.x.baseVal.value = 198;
        this.ufoElement.y.baseVal.value = 37;
        this.frames = 0;
        this.exploding = false;
        this.displayingScore = false;

        //Init (SVG/HMTL)
        this.ufoScoreGroup.attributes.display.value = "none";
        this.ufoElement.attributes.display.value = "none";
        if (soundEnabled && (!this.ufoAudioElement.paused))
            this.ufoAudioElement.pause();
        if (soundEnabled && (!this.ufoDeadAudio.paused))
            this.ufoDeadAudio.pause();
    }

    Ufo.prototype = {
        start: function () {
            if ((state.playing) && (invaders.invaderQueue.length > 9)) {
                if (this.direction === -1) {
                    this.x = 198;
                    this.ufoElement.x.baseVal.value = 198;
                }
                else {
                    this.x = 16;
                    this.ufoElement.x.baseVal.value = 16;
                }
                this.active = true;
                if (soundEnabled && !this.ufoAudioElement.muted) {
                    this.ufoAudioElement.play();
                }
                this.ufoElement.attributes.display.value = "inline";
            }
        },
        reset: function () {
            this.active = false;
            if ((soundEnabled) && (!this.ufoAudioElement.paused))
                this.ufoAudioElement.pause();
            this.ufoElement.attributes.display.value = "none";
            var rand = Math.random();
            if (rand < 0.5)
                this.direction = 1;
            else
                this.direction = -1;
            this.countdown = (Math.floor(Math.random() * 32) + 8) * 60;
        },
        moveAndRender: function () {
            if (this.active) {
                if (!isFrameSkip) {
                    this.x = this.x + (1.5 * this.direction);
                    this.ufoElement.x.baseVal.value = this.x;
                    if ((this.x < 12) || (this.x > 198))
                        this.reset();
                }
            }
            else {
                this.countdown--;
                if (this.countdown === 0) {
                    this.start();
                }
            }
            if (this.displayingScore) {
                if (this.frames === 0) {
                    this.displayingScore = false;
                    this.ufoScoreGroup.attributes.display.value = "none";
                }
                else if (this.frames === 110) {
                    this.ufoScoreGroup.attributes.display.value = "inline";
                    this.frames--;
                }
                else {
                    this.frames--;
                }
            }
        },
        ufoSound: function () {
            if (soundEnabled && this.active && !this.exploding && !this.ufoAudioElement.muted) {
                this.ufoAudioElement.play();
            }
        },
        displayScore: function (score, x, y) {
            this.displayingScore = true;
            this.frames = 130;
            this.ufoScoreGroupMatrix.e = x - 3;
            this.ufoScoreGroupMatrix.f = y - 6;
            if (score === 50) {
                this.digitElements[0].attributes.display.value = "none";
                this.digitElements[1].href.baseVal = "#Digit5";
                this.digitElements[2].href.baseVal = "#Digit0";
            }
            else {
                var scoreText = "" + score;
                this.digitElements[0].attributes.display.value = "inline";
                this.digitElements[0].href.baseVal = "#Digit" + scoreText.substring(0, 1);
                this.digitElements[1].href.baseVal = "#Digit" + scoreText.substring(1, 2);
                this.digitElements[2].href.baseVal = "#Digit" + scoreText.substring(2, 3);
            }
        },
        hitTest: function (x, y) {
            if (this.active
                && (y < 44)
                && (y > 37)
                && (x >= this.x)
                && (x < (this.x + 16))
                ) {
                if (soundEnabled && !this.ufoDeadAudio.muted)
                    this.ufoDeadAudio.play();
                this.explode();
                // Calculate mystery score
                var ufoScore = Math.round((Math.random() * 6) + 0.5) * 50;
                scoring.add(ufoScore);
                this.displayScore(ufoScore, Math.floor(this.x), 37);
                this.reset();
                return true;
            }
            else
                return false;
        },
        explode: function () {
            // Animation is handled by bullet
            if ((soundEnabled) && (!this.ufoAudioElement.paused))
                this.ufoAudioElement.pause();
            this.exploding = true;
            this.active = false;
        }
    };

    ///
    ////  END Ufo Class
    /////

    ///// 
    ////  Lives Class
    ///
    function Lives() {

        // Properties
        this.awarded = false;
        this.count = 3;
        this.livesGroup = $SVG("livesGroup");
        this.countElement = $SVG("livesCount");
        this.extraLifeAudio = $DOM("extraLifeAudio");

        // Init
        this.render();
    }

    // Methods
    Lives.prototype = {
        add: function () {
            // An extra life at 1500 - and that's all you are getting folks!
            if (!this.awarded) {
                this.count = this.count + 1;
                this.awarded = true;
                this.render();
                this.sound();
            }
        },
        deduct: function () {
            this.count = this.count - 1;
            this.render();
        },
        render: function () {
            this.countElement.href.baseVal = "#Digit" + this.count;

            var livesElements = this.livesGroup.getElementsByTagName("use");
            var length = livesElements.length;

            for (var i = 1; i < length; i++) {
                this.livesGroup.removeChild(livesElements[1]);
            }

            for (i = 1; i < this.count; i++) {
                var gunLifeElement = document.createElementNS(svgns, "use");
                gunLifeElement.id = "gunLife" + i;
                gunLifeElement.href.baseVal = "#GunPath";
                gunLifeElement.x.baseVal.value = 16 + (i * 16);
                gunLifeElement.y.baseVal.value = 231;
                this.livesGroup.appendChild(gunLifeElement);
            }
        },
        reset: function () {
            this.count = 3;
            this.render();
        },
        sound: function () {
            if (soundEnabled && !this.extraLifeAudio.muted)
                this.extraLifeAudio.play();
        }
    };

    ///
    ////  END Lives Class
    /////

    /////
    ////  GameOverMessage Class - Animate Game Over Message
    ///
    function GameOverMessage() {

        //Properties
        this.gameOverGroup = $SVG("gameOverGroup");
        this.gameOverGroupMatrix = this.gameOverGroup.transform.baseVal.getItem(0).matrix;
        this.letters = this.gameOverGroup.getElementsByTagName("path");
        this.active = false;
        this.letterDelay = 8;  // letter appearance speed
        this.frames = 0;
        this.letterIndex = 0;
        this.mourningTime = (this.letterDelay * this.letters.length) + 120;
    }

    GameOverMessage.prototype = {
        render: function () {
            // Activate this
            if (!this.active) {
                this.reset();
                this.active = true;
            }
            // Animate this
            if (this.active && ((this.frames % this.letterDelay) === 0)) {
                if (this.letterIndex < 8) {
                    // make next letter visible
                    this.letters[this.letterIndex].attributes.display.value = "inline";
                    this.letterIndex++;
                }
            }
            // Exit this
            if (this.frames > this.mourningTime) {
                this.active = false;
                this.reset();
                state.reset();
                state.halted = true;
            }
            this.frames++;
        },
        reset: function () {
            this.letterIndex = 0;
            // Init (SVG Elements)
            for (var i = 0; i < 8; i++) {
                this.letters[i].attributes.display.value = "none";
            }
            this.gameOverGroupMatrix.e = 73;
            this.gameOverGroupMatrix.f = 49;
        }
    };

    ///
    ////  END Game Over Message
    /////


    ///// 
    ////  Scoring Class
    ///
    function Scoring() {
        // Properties
        this.score = 0;
        this.highScoreElement = $SVG("highScore");
        this.scoreElement = $SVG("score");
        // Initialise High Score from storage
        if (store.get("highScore") === null) {
            store.set("highScore", 0);
        }
        // Render Scores
        this.render(store.get("highScore"), "highScore");
        this.render(this.score, "score");
    }

    Scoring.prototype = {
        updateByInvader: function (invader) {
            // Calculate
            this.add((Math.floor(invader.row / 2) + 1) * 10);
        },
        add: function (value) {
            this.score = this.score + value;
            this.render(this.score, "score");
            // Handle high score
            if (this.score > store.get("highScore")) {
                store.set("highScore", this.score);
                this.render(this.score, "highScore");
            }
            // Award extra life
            if ((!lives.awarded) && (this.score >= 1500)) {
                lives.add();
            }
        },
        padLeft: function (value, width, chr) {
            return (("" + value).length >= width) ? "" + value : this.padLeft(chr + value, width, chr);
        },
        render: function (value, elementId) {
            var scoreText = this.padLeft(value, 4, "0");
            var x, scoreGroup;
            // Delete old digits
            if (elementId === "score") {
                scoreGroup = this.scoreElement;
                x = 25;
            }
            else {
                scoreGroup = this.highScoreElement;
                x = 89;
            }
            var digitElements = scoreGroup.getElementsByTagName("use");
            var length = digitElements.length;
            for (var i = 0; i < length; i++) {
                scoreGroup.removeChild(digitElements[0]);
            }
            // Append new digits
            for (i = 0; i < scoreText.length; i++) {
                var scoreElement = document.createElementNS(svgns, "use");
                scoreElement.id = elementId + i;
                scoreElement.href.baseVal = "#Digit" + scoreText[i];
                scoreElement.x.baseVal.value = x + (i * 8);
                scoreElement.y.baseVal.value = 16;
                scoreElement.setAttributeNS(null, "fill", "#8FF");
                scoreGroup.appendChild(scoreElement);
            }
        }
    };

    ///
    ////  END Scoring Class
    /////


    ///// 
    ////  Invaders Class
    ///
    function Invaders() {

        // Properties
        this.invaderQueue = [];
        this.invaderArray = [];
        this.lowestInvaders = [];
        this.nextInvader = 0;
        this.currentDirection = 2;
        this.yOffset = 0;
        this.nextBomb = 120;
        this.bombFrequency = 16;
        this.BBox = {};

        // Perform initialisation
        this.init();
    }

    // Events/Methods
    Invaders.prototype = {
        moveAndRender: function () {
            if (this.invaderQueue.length === 1) {
                state.reset();
                state.nextLevel = true;
            }
            else {
                var currentInvader = this.invaderQueue.shift();
                // Change direction just once per queue cycle (hence a marker)
                if (currentInvader.id === "marker") {
                    this.yOffset = 0;
                    // push marker back onto queue
                    this.invaderQueue.push(currentInvader);
                    this.dropBombs();
                    this.BBox = this.getBBox();
                    this.changeDirection();
                    // fetch first invader
                    currentInvader = this.invaderQueue.shift();
                }
                currentInvader.move(this.currentDirection, this.yOffset);
                currentInvader.render();
                this.invaderQueue.push(currentInvader);
            }
            this.nextBomb--;
        },
        getBBox: function () {
            var xMin = 224, xMax = 0, yMin = 240, yMax = 0;
            // Used to work out which invaders in BBox
            var xMinInvader, yMinInvader;
            // Used in hit-test - and refreshed at marker
            for (var i = 0; i < this.invaderQueue.length; i++) {
                if (this.invaderQueue[i].id !== "marker") {
                    var x = this.invaderQueue[i].matrix.e;
                    var y = this.invaderQueue[i].matrix.f;
                    if (x < xMin) {
                        xMinInvader = this.invaderQueue[i];
                        xMin = x;
                    }
                    if (y < yMin) {
                        yMinInvader = this.invaderQueue[i];
                        yMin = y;
                    }
                    if (x > xMax) {
                        xMax = x;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                }
            }
            return { "xMin": xMin, "xMax": xMax + 12, "yMin": yMin, "yMax": yMax + 8, "xMinInvader": xMinInvader, "yMinInvader": yMinInvader };
        },
        destroy: function (index) {
            var deadInvader = this.invaderQueue.splice(index, 1);
            deadInvader[0].destroy();
        },
        destroyAll: function () {
            for (var row = 0; row < 5; row++) {
                for (var column = 0; column < 11; column++) {
                    this.invaderArray[(row * 11) + column].destroy();
                }
            }
        },
        init: function () {
            // Initialise invader queue
            for (var row = 0; row < 5; row++) {
                for (var column = 0; column < 11; column++) {
                    var invader = new Invader(column, row);
                    this.invaderQueue.push(invader);
                    this.invaderArray[(row * 11) + column] = invader;
                }
            }
            // Insert a rotation end-marker
            this.invaderQueue.push(new Invader(112, -1));
            // Prepare the invaderY offset, for next time
            if (invaderY === 120) {
                invaderY = invaderY + 24;
            }
            else if (invaderY === 144) {
                invaderY = invaderY + 16;
            }
            else if (invaderY < 176) {
                invaderY = invaderY + 8;
            }
        },
        changeDirection: function () {
            if ((this.BBox.xMin < 12) && (this.currentDirection !== 2)) {
                this.currentDirection = 2;
                this.yOffset = 8;
            }
            if ((this.BBox.xMax > 213) && (this.currentDirection !== -2)) {
                this.currentDirection = -2;
                this.yOffset = 8;
            }
        },
        invadersHitTest: function (x, y) {
            var isHit = false;
            if ((y >= this.BBox.yMin) && (y <= this.BBox.yMax + 2) && (x >= this.BBox.xMin - 2) && (x < this.BBox.xMax + 2)) {
                var invader = this.invaderAtXY(x, y);
                isHit = (invader.active && invader.hitTest(x, y));
                if (isHit) {
                    scoring.updateByInvader(invader);
                    for (var i = 0; i < this.invaderQueue.length; i++) {
                        if (invader.id === this.invaderQueue[i].id) {
                            this.destroy(i);
                            break;
                        }
                    }
                }
            }
            return isHit;
        },
        invaderAtXY: function (x, y) {
            // Use BBox to determine which invader to hit-test.
            var column = Math.floor((x - this.BBox.xMin) / 16) + this.BBox.xMinInvader.column;
            var row = 4 - (Math.floor((y - this.BBox.yMin) / 16) + (4 - this.BBox.yMinInvader.row));
            // Ensure always inside array, because invaders move faster than BBox changes
            if (column < 0) column = 0;
            if (column > 10) column = 10;
            if (row < 0) row = 0;
            if (row > 4) row = 4;
            return this.invaderArray[(row * 11) + column];
        },
        shift: function (xOffset) {
            for (var i = 0; i < this.invaderQueue.length; i++) {
                this.invaderQueue[i].matrix.e = this.invaderQueue[i].matrix.e + xOffset;
            }
        },
        findLowestInvaders: function () {
            // Find the lowest active invader per column if there is one (for bombing)
            this.lowestInvaders = [];
            for (var column = 0; column < 11; column++) {
                for (var row = 0; row < 5; row++) {
                    var invader = this.invaderArray[(row * 11) + column];
                    if (invader.active) {
                        this.lowestInvaders.push(invader);
                        break;
                    }
                }
            }
        },
        findNearestInvader: function (x) {
            // Choose the nearest invader (to make player move)
            var chosenInvader;
            var distance = 240;
            for (var i = 0; i < (this.invaderQueue.length - 1) ; i++) {
                if ((this.invaderQueue[i].id !== "marker") && (Math.abs(this.invaderQueue[i].matrix.e - x) < distance)) {
                    chosenInvader = this.invaderQueue[i];
                    distance = Math.abs(this.invaderQueue[i].matrix.e - x);
                }
            }
            return chosenInvader;
        },
        findNextBomber: function () {
            this.findLowestInvaders();
            var random = Math.random();
            // Every 3rd bomb is dropped by the nearest invader
            if ((random * 3) > 1)
                return this.lowestInvaders[Math.floor(this.lowestInvaders.length * random)];
            else
                return this.findNearestInvader(gun.x);
        },
        dropBombs: function () {
            if ((this.nextBomb <= 0)
                && ((typeof bomb === "undefined") || (typeof missile === "undefined") || (!bomb.active) || (!missile.active))) {
                // Choose bomber
                var theChosenOne = this.findNextBomber();
                // Choose bomb style
                var path = (Math.random() > 0.5) ? BombPath : MissilePath;
                var newBomb = new Bomb(path, theChosenOne.matrix.e + 4, theChosenOne.matrix.f);
                if ((typeof bomb === "undefined") || (!bomb.active))
                    bomb = newBomb;
                else
                    missile = newBomb;
                // bombs are 8 pixels high, but move @ 2 pixels so 4 should lead to no clashes
                this.nextBomb = Math.floor((Math.random() * this.bombFrequency)) + 4;
            }
        }
    };

    ///
    ////  END Invaders Class
    /////


    ///// 
    ////  Invader Class
    ///
    function Invader(column, row) {
        // Properties
        this.column = column;
        this.row = row;
        this.spriteA = true;
        this.spriteAClip = "url(#C" + (Math.floor(this.row / 2)).toString() + "A)";
        this.spriteBClip = "url(#C" + (Math.floor(this.row / 2)).toString() + "B)";
        // For hit test calculation 
        if (this.row < 2) {
            this.xMin = 0;
            this.xMax = 12;
        }
        else if (this.row < 4) {
            this.xMin = 1;
            this.xMax = 12;
        }
        else {
            this.xMin = 2;
            this.xMax = 10;
        }

        this.position = column + (row * 11);
        this.spriteType = Math.floor(row / 2);

        if (row === -1) {
            this.id = "marker";     // Probably should be a boolean
            this.active = false;
        }
        else {
            this.element = invaderElemArray[this.position];
            this.clipPath = this.element.attributes["clip-path"];
            this.matrix = this.element.transform.baseVal.getItem(0).matrix;
            this.matrix.e = 26 + (column * 16);
            this.matrix.f = invaderY - (row * 16);
            this.id = "invader" + this.position;
            this.active = true;
            // we want the invaders to appear one-by-one, "visible" is false initially
            this.visible = false;
        }

        this.deadAlienAudio = $DOM("deadAlienAudio");
        this.direction = 2;
        this.frames = 0;
        // mask is just a black blob, 16 pixels-wide
        this.invaderMask = new Mask([65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535], 16);
    }

    // Methods
    Invader.prototype = {
        move: function (currentDirection, yOffset) {
            // Move first and then change direction, for next time.
            if (this.direction !== currentDirection)
                this.direction = currentDirection;
            else {
                this.matrix.e += this.direction;
            }
            if (yOffset) {
                this.matrix.f += yOffset;
            }
            // Handle reaching the bottom
            if (this.matrix.f > 200) {
                state.reset();
                state.invaded = true; // it's not game over until the gun has stopped exploding.
                gun.hit();
            }
            // Handle running into barriers
            if (this.matrix.f >= 184)
                barriers.applyMask(this.invaderMask, this.matrix.e - 2, this.matrix.f);
        },
        render: function () {
            if (this.spriteA)
                this.clipPath.value = this.spriteAClip;
            else
                this.clipPath.value = this.spriteBClip;
            this.spriteA = !this.spriteA;
            if (!this.visible) {
                this.element.attributes.display.value = "inherit";
                this.visible = true;
            }
        },
        destroy: function () {
            this.element.attributes.display.value = "none";
            this.active = false;
            this.visible = false;
        },
        hitTest: function (x, y) {
            var isHit = false;
            if (this.element.id !== "marker") {
                var relX = x - this.matrix.e;
                var relY = y - this.matrix.f;
                isHit = ((relX >= this.xMin) && (relX < this.xMax) && (relY > 0) && (relY < 8));
                if (isHit) {
                    this.sound();
                    this.invaderExplode();
                }
            }
            return isHit;
        },
        invaderExplode: function () {
            // Make bullet position match the invader, for explosion (handled by bullet)
            bullet.x = this.matrix.e;
            bullet.y = this.matrix.f;
            this.active = false;
        },
        sound: function () {
            if (soundEnabled && !this.deadAlienAudio.muted)
                this.deadAlienAudio.play();
        }
    };

    ///
    ////  END Invader Class
    /////

    ///// 
    ////  Bullet Class
    ///
    function Bullet() {
        // Properties
        this.bulletRectElement = $SVG("bulletRect");
        this.bulletGroupElement = $SVG("bulletGroup");
        this.shooting = false;
        this.exploding = false;
        this.bulletRectElement.attributes.display.value = "none";
        this.x = 24;
        this.y = 208;
        this.frame = 0;
        this.audioElm = $DOM("shootAudio");
        this.bulletHoleMask = new Mask([137, 34, 126, 255, 255, 126, 36, 145], 8);
    }

    // Methods
    Bullet.prototype = {
        move: function () {
            if (gun.active && !gun.exploding && keyShootPressed && !this.shooting && !this.exploding) {
                keyShootPressed = false;
                this.sound();
                this.shooting = true;
                this.exploding = false;
                this.bulletRectElement.attributes.display.value = "inline";
                this.x = gun.x;
                this.bulletRectElement.x.baseVal.value = this.x;
            }
            var collisionY = false;
            if (this.shooting) {
                this.y = this.y - 4;
                if (this.y < 32) {
                    this.bulletExplode("#BulletZap", "#F00", this.x - 3, this.y - 2);
                }
                else {
                    collisionY = barriers.hitTest(this.x, this.y, false);
                    if (collisionY) {
                        barriers.applyMask(this.bulletHoleMask, this.x - 4, collisionY - 5);
                        this.bulletExplode("#BulletZap", "#0F0", this.x - 4, collisionY - 5);
                    }
                    else if ((this.y < 44) && (ufo.hitTest(this.x, this.y))) {
                        this.bulletExplode("#UfoZap", null, ufo.ufoElement.x.baseVal.value - 2, ufo.ufoElement.y.baseVal.value - 5);
                    }
                    else if (invaders.invadersHitTest(this.x, this.y)) {
                        // Hit-test changed x/y position to match invader
                        this.bulletExplode("#InvaderZap", null, this.x, this.y);
                    }
                    else if ((typeof bomb !== "undefined") && (bomb.hitTest(this.x, this.y))) {
                        this.bulletExplode("#BulletZap", "#FFF", this.x - 3, this.y);
                    }
                    else if ((typeof missile !== "undefined") && (missile.hitTest(this.x, this.y))) {
                        this.bulletExplode("#BulletZap", "#FFF", this.x, this.y);
                    }
                }
            }
            else if (this.exploding) {
                if (this.frames === 0) {
                    this.destroy();
                }
                else {
                    if (!isFrameSkip)
                        bulletExplodeElement.attributes.opacity.value = this.frames / 16;
                    this.frames--;
                }
            }
        },
        render: function () {
            if ((this.shooting) && (!isFrameSkip)) {
                this.bulletRectElement.y.baseVal.value = this.y;
            }
        },
        destroy: function () {
            this.shooting = false;
            this.exploding = false;
            bulletExplodeElement.attributes.display.value = "none";
            this.bulletRectElement = $SVG("bulletRect");
            this.y = 208;
        },
        sound: function () {
            if (soundEnabled && !this.audioElm.muted)
                this.audioElm.play();
        },
        bulletExplode: function (elementId, colour, x, y) {
            // Handle explosion
            this.shooting = false;
            this.exploding = true;
            this.bulletRectElement.attributes.display.value = "none";
            bulletExplodeElement.href.baseVal = elementId;
            if ((typeof colour !== "undefined") && (colour !== null))
                bulletExplodeElement.attributes.fill.value = colour;
            bulletExplodeElement.x.baseVal.value = x;
            bulletExplodeElement.y.baseVal.value = y;
            bulletExplodeElement.attributes.opacity.value = 1;
            bulletExplodeElement.attributes.display.value = "inline";
            this.frames = 16;
        }
    };

    ///
    ////  END Bullet Class
    /////

    ///// 
    ////  Gun Class
    ///
    function Gun(xPos, yPos, gunElement) {
        // Private members
        this.gunHitElement = $SVG("gunHit");
        this.delay = 4;      // Gunhit - animation flipping speed
        this.duration = 16;  // Duration of gunHit - no of frames
        this.frames = 0;
        this.width = 13;
        this.height = 8;

        // Properties
        this.element = gunElement;
        this.min = 24;
        this.max = 193;
        this.x = this.min;
        this.y = 208;
        this.deadAudio = $DOM("deadAudio");
        this.active = true;  // false if exploding, marker
        this.exploding = false;
        this.hasMoved = false;

        // Init
        this.gunHitElement.attributes.display.value = "none";
        this.element.x.baseVal.value = this.x;
        this.element.y.baseVal.value = this.y;
        this.element.attributes.display.value = "inline";
    }

    Gun.prototype = {
        hit: function () {
            if (!this.exploding) {
                if (soundEnabled && !this.deadAudio.muted)
                    this.deadAudio.play();
                this.exploding = true;
            }
            // Flip sprites, every so often
            if ((Math.floor(this.frames / this.delay) % 2) === 0) {
                this.gunHitElement.href.baseVal = "#GunHitPathA";
                this.gunHitElement.attributes.opacity.value = ((64 - this.frames) / 64);
            }
            else {
                this.gunHitElement.href.baseVal = "#GunHitPathB";
            }
            // Make gunHit element visible
            if (this.frames === 0) {
                // Align with gun
                this.gunHitElement.x.baseVal.value = this.x - 8;
                this.element.attributes.display.value = "none";
                this.gunHitElement.attributes.display.value = "inline";
            }
            this.frames++;
            // End the animation
            if (this.frames > (this.duration * this.delay)) {
                if ((state.invaded) || (lives.count === 0)) {
                    //invaded or no more lives -> gameOver
                    state.reset();
                    state.gameOver = true;
                }
                else {
                    this.reincarnate();
                }
                this.frames = 0;
                this.exploding = false;
                this.gunHitElement.attributes.display.value = "none";
            }
        },
        hitTest: function (x, y) {
            if (this.exploding)
                return false;
            var killed = (((y + 8) > this.y) && (y < this.y) && (x > (this.x - 8)) && (x < (this.x + 5)));
            if (killed) {
                lives.deduct();
                if (lives.count > 0)
                    invaders.nextBomb += 120; // 2 second respite
                this.hit();
            }
            return killed;
        },
        reincarnate: function () {
            this.x = this.min;
            this.y = 208;
            this.exploding = false;
            this.element.attributes.display.value = "inline";
            this.hasMoved = true;
            isFrameSkip = false;
            this.render();
        },
        render: function () {
            if (this.exploding) {
                this.hit();
            }
            else {
                if (!isFrameSkip && (this.hasMoved)) {
                    this.element.x.baseVal.value = this.x;
                    this.element.y.baseVal.value = this.y;
                    this.hasMoved = false;
                }
            }
        },
        move: function () {
            if ((!this.exploding) && this.active && (!((keyRightPressed) && (keyLeftPressed)))) {
                if ((keyLeftPressed) && (this.x > this.min)) {
                    this.hasMoved = true;
                    this.x = this.x - 1;
                }
                else if ((keyRightPressed) && (this.x < this.max)) {
                    this.hasMoved = true;
                    this.x = this.x + 1;
                }
            }
        }
    };

    ///
    ////  END Gun Class
    /////

    ///// 
    ////  Keyboard Handling - as per SVG-Oids
    ///
    function KeyPress(key) {
        if (key.keyCode === 32 || key.keyCode === 87 || key.keyCode === 38 || key.keyCode === 83 || key.keyCode === 40)
            key.preventDefault();
    }

    // Handle these...
    function KeyDown(key) {
        var code;

        if (typeof window.event === "undefined") {
            code = key.keyCode;
        }
        else {
            code = window.event.keyCode;
        }
        if (code === 70) {
            fpsText.show();
        }
        if (code === 66) {
            background.toggle();
        }
        if (code === 77) {
            mute.toggle();
        }
        else {
            // Otherwise debounce the key.
            return ToggleKey(code, true, key);
        }
        key.preventDefault();
    }

    // Handle FPS Toggle
    function KeyUp(key) {
        var code;

        if (typeof window.event === "undefined") {
            code = key.keyCode;
        }
        else {
            code = window.event.keyCode;
        }
        return ToggleKey(code, false, key);
    }

    // Toggles whether key is "pressed" -called from key-up/key-down events
    function ToggleKey(key, pressed, evt) {
        if (key === 65 || key === 37) {
            keyLeftPressed = pressed;
        }
        else if (key === 68 || key === 39) {
            keyRightPressed = pressed;
        }
        else if (key === 32 || key === 17 || key === 13) {
            keyShootPressed = pressed;
        }
        else if (key === 80) {
            keyPausePressed = pressed;
        }
        else
            return true;  // let others have the key
        evt.preventDefault();
        return false;
    }

    ///
    ////  END Keyboard Handling
    /////

    ///// 
    ////  Bomb Class
    ///
    function Bomb(path, x, y) {
        // Properties
        this.x = x + Math.round(Math.random()); // to defeat even pixel bias
        this.y = y;
        this.element = availableBombs.shift();
        //Defaults
        this.element.attributes.d.value = path[0];
        this.element.attributes.opacity.value = "1";
        this.element.attributes.fill.value = "#FFF";
        this.element.attributes.display.value = "inline";
        this.matrix = this.element.transform.baseVal.getItem(0).matrix;
        this.matrix.e = this.x;
        this.matrix.f = this.y;

        this.active = true;
        this.exploding = false;
        this.fast = true;

        this.frame = 0;
        this.sprite = 0;
        this.path = path;
        this.craterMask = new Mask([12, 38, 13, 30, 46, 31, 46, 21], 6);
    }

    // Methods
    Bomb.prototype = {
        moveAndRender: function () {
            var collisionY = false;
            if ((state.gameOver || state.nextLevel) && ((this.active) || (this.exploding))) {
                this.frames = 0;
                this.destroy();
            }
            else if (this.exploding) {
                if (this.frames === 0)
                    this.destroy();
                else {
                    if (!isFrameSkip) {
                        this.element.attributes.opacity.value = this.frames / 16;
                    }
                    this.frames--;
                }
            }
            else if (this.active) {
                // Artifically reduce speed by a third for authenticity
                this.y = this.y + 1 + this.fast;
                this.fast = !this.fast;
                // Test for collision/end
                if (this.y > 221) {
                    this.bombExplode(BombExplodeBottomPath, "#0F0");
                }
                else if (gun.hitTest(this.x, this.y)) {
                    this.destroy();
                    if ((typeof missile !== "undefined") && (missile.active))
                        missile.destroy();
                    if ((typeof bomb !== "undefined") && (bomb.active))
                        bomb.destroy();
                }
                else {
                    var zigzagFactor = (this.sprite % 3) - 1;
                    collisionY = barriers.hitTest(this.x + zigzagFactor, this.y + 7, true);
                    if (collisionY) {
                        // Impact crater depth factor
                        this.y = collisionY - 5 + Math.floor((Math.random() * 4));
                        barriers.applyMask(this.craterMask, this.x + zigzagFactor - (this.craterMask.width / 2), this.y);
                        this.bombExplode(BombExplodePath, "#0F0");
                    }
                }
            }
            this.render();
        },
        render: function () {
            if ((!isFrameSkip) && (this.active) && (!this.exploding)) {
                this.matrix.f = this.y;
                this.element.attributes.d.value = this.path[this.sprite];
                this.sprite = (this.sprite + 1) % 4;
            }
        },
        destroy: function () {
            this.active = false;
            this.exploding = false;
            this.frames = 0;
            availableBombs.push(this.element);
            this.element.attributes.display.value = "none";
        },
        bombExplode: function (path, colour) {
            // Handle explosion
            this.exploding = true;
            this.element.attributes.d.value = path;
            this.element.attributes.fill.value = colour;
            this.x = this.x - (this.craterMask.width / 2);
            this.matrix.e = this.x;
            this.matrix.f = this.y;
            this.frames = 16; // this affects opacity
            this.sprite = 0;
        },
        hitTest: function (x, y) {
            // Called from bullet class
            if ((this.active && !this.exploding && (y <= this.y) && (y <= (this.y - 7)) && (x >= this.x) && (x < this.x + 3))) {
                this.x = x;
                this.y = y;
                this.bombExplode(BombExplodePath, "#FFF");
                return true;
            }
            return false;
        }
    };

    ///
    ////  END Bomb Class
    /////

    ///// 
    ////  Barriers Class
    ///
    function Barriers() {
        this.active = (invaderY < 176);

        if (this.active) {
            this.barriers = [new Barrier(32, 184), new Barrier(77, 184), new Barrier(122, 184), new Barrier(167, 184)];
            // initialise
            for (var i = 0; i < this.barriers.length; i++) {
                this.barriers[i].render();
            }
        }
    }

    Barriers.prototype = {
        hitTest: function (x, y, isBomb) {
            if (this.active) {
                var collisionY = false;
                for (var i = 0; i < this.barriers.length; i++) {
                    // Handle simple cases
                    if ((x >= this.barriers[i].x) &&
                    (x < (this.barriers[i].x + this.barriers[i].width)) &&
                    (y >= this.barriers[i].y) &&
                    (y < (this.barriers[i].y + this.barriers[i].height))
                ) {
                        if (isBomb)
                            collisionY = this.barriers[i].bombHitTest(x, y);
                        else
                            collisionY = this.barriers[i].bulletHitTest(x, y);
                        if (collisionY) break;
                    }
                }
                return collisionY;
            }
            else return false;
        },
        destroy: function () {
            // Remove the barrier svg elements (if they exist)
            if (this.active) {
                for (var i = 0; i < this.barriers.length; i++) {
                    this.barriers[i].destroy();
                }
            }
        },
        applyMask: function (mask, x, y) {
            if (this.active) {
                // Note: partial mask might be applied to left of barrier,hence "(x + mask.width)"
                for (var i = 0; i < this.barriers.length; i++) {
                    if (((x + mask.width) > this.barriers[i].x) && (x < (this.barriers[i].x + this.barriers[i].width))) {
                        this.barriers[i].applyMask(mask, x, y);
                        break;
                    }
                }
            }
        }
    };
    ///
    ////  END Barriers Class
    /////

    ///// 
    ////  Mask Class
    ///
    function Mask(bits, width) {
        this.bitArray = bits;
        this.height = bits.length;
        this.width = width; // mask is effectively right-justified
    }
    ///
    ////  END Mask Class
    /////

    ///// 
    ////  Barrier Class
    ///
    function Barrier(x, y) {
        // Properties
        this.x = x;
        this.y = y;
        this.barrierBits = [262128, 524280, 1048572, 2097150, 4194303, 4194303, 4194303, 4194303, 4194303, 4194303, 4194303, 4194303, 4161791, 4128895, 4063295, 4063295];
        this.width = 22;
        this.height = this.barrierBits.length;

        // Init
        this.element = document.createElementNS(svgns, "path");
        this.element.setAttributeNS(null, "fill", "url(#greenGradient)");
        this.element.setAttributeNS(null, "display", "inline");
        this.element.setAttributeNS(null, "transform", "translate(" + this.x + "," + this.y + ")");
        this.render();
        this.barrierGroup = $SVG("barrierGroup");
        this.barrierGroup.appendChild(this.element);
    }

    // Methods
    Barrier.prototype = {
        bitsToPath: function (bits, width) {
            var result = [""];
            var x = 0;
            for (var row = 0; row < bits.length; row++) {
                for (var column = width - 1; column > -1; column--) {
                    x = (width - 1 - column);
                    if (((1 << column) & bits[row]) > 0) {
                        result.push("M" + x + "," + row + "v1h1v-1z");
                    }
                }
            }
            return result.join("");
        },
        render: function () {
            var path = this.bitsToPath(this.barrierBits, this.width);
            this.element.setAttributeNS(null, "d", path);
        },
        bulletHitTest: function (x, y) {
            // BulletHitTest - like bombHitTest, but different direction. Bullet speed is 4 pixels.
            var relativeX = x - this.x;
            var relativeY = y - this.y;
            // just to stop overflow
            var maxRow = (relativeY + 3 < this.height) ? 3 : (this.y + this.height - 1) - y;
            // check bullet nose+3, node+2, etc. first, avoiding bits overflowing
            for (var row = maxRow; row > -1; row--) {
                if ((this.barrierBits[relativeY + row] & (1 << (this.width - 1 - relativeX))) > 0) {
                    return this.y + relativeY + row;
                }
            }
            return false;
        },
        bombHitTest: function (x, y) {
            // BombHitTest - like bulletHitTest. Same, same, but different.
            var relativeX = x - this.x;
            var relativeY = y - this.y;
            if (relativeY < 0)
                return false;
            else if ((relativeY < this.height) && ((this.barrierBits[relativeY] & (1 << (this.width - 1 - relativeX))) > 0)) {
                return y;
            }
            else if ((relativeY + 1 < this.height) && ((this.barrierBits[relativeY + 1] & (1 << (this.width - 1 - relativeX))) > 0)) {
                return y + 1;
            }
            else
                return false;
        },
        applyMask: function (mask, mX, mY) {
            // Mask the required bits at the required position...
            if (((mY + mask.height) < this.y) || ((this.y + this.height) < mY) || ((mX + mask.width) < this.x) || ((this.x + this.width) < mX))
                return;
            var maskMinY = (mY > this.y) ? 0 : this.y - mY;
            var minY = (mY > this.y) ? mY - this.y : 0;
            var maxY = ((mY + mask.height) >= (this.y + this.height)) ? this.height : (mY + mask.height - this.y);
            var xShift = (this.width - mask.width) - (mX - this.x);
            for (var row = 0; row < (maxY - minY) ; row++) {
                var bitMask = mask.bitArray[row + maskMinY];
                bitMask = (xShift > 0) ? (bitMask << xShift) : bitMask >> -xShift;
                this.barrierBits[row + minY] &= ~(bitMask);
            }
            // ...and render
            this.render();
        },
        destroy: function () {
            this.barrierGroup.removeChild(this.element);
        }
    };
    ///
    ////  END Barrier Class
    /////

    ///// 
    ////  Marching (sound) Class
    ///
    function Marching() {
        // Marching Sounds
        this.active = false;
        this.marchSoundTimer = 0;
        this.marchSoundDelay = 960;
        this.audioElements = [
            $DOM("march1Audio"),
            $DOM("march2Audio"),
            $DOM("march3Audio"),
            $DOM("march4Audio")
        ];
        this.audioElementIndex = 0;

        // Init
        if (this.marchSoundTimer !== 0)
            clearTimeout(this.marchSoundTimer);
    }

    // Methods
    Marching.prototype = {
        start: function () {
            if (this.marchSoundTimer !== 0)
                clearTimeout(this.marchSoundTimer);
            // note: wrapper function calls "marching" method for instance context in timer event
            this.marchSoundTimer = setTimeout(function () { marching.event(); }, this.marchSoundDelay);
            this.active = true;
        },
        stop: function () {
            if (this.marchSoundTimer !== 0)
                clearTimeout(this.marchSoundTimer);
            this.active = false;
        },
        event: function () {
            if (state.playing) {
                this.audioElementIndex = ((this.audioElementIndex + 1) % 4);
                if (soundEnabled && !this.audioElements[this.audioElementIndex].muted) {
                    this.audioElements[this.audioElementIndex].currentTime = 0;
                    this.audioElements[this.audioElementIndex].play();
                }
                this.marchSoundDelay = ((invaders.invaderQueue.length / 56) * 920) + 40;
                this.start();
            }
            else {
                if (this.marchSoundTimer !== 0)
                    clearTimeout(this.marchSoundTimer);
            }
        }
    };

    ///
    ////  END Marching Class
    /////


    ///// 
    ////  Frame Per Second (FPS) Class
    ///
    function FPS() {
        this.text = $SVG("fps");
    }

    FPS.prototype = {
        // UpdateFPS() - Called from timer event every half-second
        update: function () {
            var d = new Date();
            var currentTime = d.getTime();
            var dt = currentTime - lastFPSUpdateTime;
            framesPerSecond = (frameCount / dt * 1000).toFixed(2);
            this.text.firstChild.nodeValue = "FPS: " + framesPerSecond;
            lastFPSUpdateTime = currentTime;
            frameCount = 0;
        },
        show: function () {
            if (showFPS) {
                this.text.attributes.display.value = "none";
                showFPS = false;
            }
            else {
                this.text.attributes.display.value = "inline";
                showFPS = true;
            }
        }
    };

    ///// 
    ////  State Class
    ///     (setup->(playing+paused)->playing->gameOver->gameOverDisplaying->halted)
    //
    function State() {
        // Game States - allow multiple states
        this.setup = true;
        this.playing = false;
        this.gameOver = false;
        this.gameOverDisplaying = false;
        this.paused = false;
        this.halted = false;
        this.nextLevel = false;
        this.invaded = false;
        // check if sound is possible
        var audioElement = $DOM("ufoAudio");
        soundEnabled = (Modernizr.audio) && (Modernizr.audio.ogg);
    }

    //Methods
    State.prototype = {
        reset: function () {
            this.playing = false;
            this.gameOver = false;
            this.gameOverDisplaying = false;
            this.paused = false;
            this.halted = false;
            this.nextLevel = false;
            this.invaded = false;
        },
        doSetup: function () {
            // Called from StartGame
            this.setup = false;
            var pausedElement = $SVG("paused");
            pausedElement.attributes.display.value = "inline";
            pausedback.attributes.display.value = "inline";
            titleSvgDocument.attributes.display.value = "inline";
            $SVG("credit1").href.baseVal = "#Digit1";
            this.paused = true;
        },
        halt: function () {
            // Called from MainLoop.
            this.halted = false; // a bit redundant
            titleSvgDocument.attributes.display.value = "inline";
            StartGame(); // creates a new state anyway
        },
        pause: function () {
            var pausedElement = $SVG("paused");
            keyPausePressed = false;
            if (state.paused) {
                // Hide the pause screen
                if (mainLoopTimer !== 0)
                    clearInterval(mainLoopTimer);
                mainLoopTimer = setInterval(MainLoop, frameInterval);
                marching.start();
                pausedElement.attributes.display.value = "none";
                pausedback.attributes.display.value = "none";
                titleSvgDocument.attributes.display.value = "none";
                $SVG("credit1").href.baseVal = "#Digit0";
                this.paused = false;
                // render the score and lives on unpause
                // (because it could be the start of a new game)
                scoring.render(scoring.score, "score");
                lives.render();
                // Enable touch controls
                if (helper.touch) {
                    restorePositions();
                    joystick.show();
                    fireButton.show();
                    pauseButton.show();
                    muteButton.show();
                }
                // Reset the about screen
                titleScreen.aboutclick();
                this.playing = true;
            }
            else {
                // Show the pause screen
                if (mainLoopTimer !== 0)
                    clearInterval(mainLoopTimer);
                mainLoopTimer = setInterval(MainLoop, 100);
                if (soundEnabled && (ufo.ufoAudioElement.readyState !== 0))
                    ufo.ufoAudioElement.pause();
                if (marching.active)
                    marching.stop();
                pausedElement.attributes.display.value = "inline";
                pausedback.attributes.display.value = "inline";
                titleSvgDocument.attributes.display.value = "inline";
                if (helper.touch) {
                    joystick.hide();
                    fireButton.hide();
                    pauseButton.hide();
                    muteButton.hide();
                }
                this.reset();
                this.paused = true;
            }
        }
    };

    ///
    ////  END State Class
    /////


    ////
    ///  Start Game - create the Game Objects, Timers, Keyboard Events, etc.
    //
    function StartGame() {
        fpsText = new FPS();
        // Initialise objects
        if (typeof store === "undefined")
            store = new Store();
        if (typeof view === "undefined")
            view = new View();
        state = new State();
        invaderY = 120;
        if (typeof marching === "undefined")
            marching = new Marching();
        gun = new Gun(18, -24, $SVG("gun"));
        bullet = new Bullet();
        // Create barriers before invaders, because invaders updates the invaderY value.
        if (typeof barriers !== "undefined")
            barriers.destroy();
        barriers = new Barriers();
        if (typeof invaders !== "undefined")
            invaders.destroyAll();
        invaders = new Invaders();
        if (typeof scoring === "undefined")
            scoring = new Scoring();
        scoring.score = 0;  // set here, and render on "unpause"
        if (typeof lives === "undefined")
            lives = new Lives();
        lives.count = 3; // set here, and render on "unpause"
        ufo = new Ufo();
        background = new Background();
        mute = new Mute();
        gameOverMessage = new GameOverMessage();
        // Timers
        if (mainLoopTimer !== 0)
            clearInterval(mainLoopTimer);
        mainLoopTimer = setInterval(MainLoop, 100);
        if (fpsTimer !== 0)
            clearInterval(fpsTimer);
        fpsTimer = setInterval(function () { fpsText.update(); }, 500);
        // Hide touch controls initially
        if (helper.touch) {
            joystick.hide();
            fireButton.hide();
            pauseButton.hide();
            playButton.show();
            
            view.Resize();
        }
        if (state.setup) {
            state.doSetup();
        }
        else {
            state.playing = true;
            state.paused = true;
        }
    }
    ///
    ////  END StartGame
    /////


    ////
    ///  Main Loop - Handles actions for the different game states.
    //
    function MainLoop() {
        // Do this twice, every 30th of a second, for speed.
        for (var i = 0; i < 2; i++) {
            // Skip redrawing in some rendering cases.
            isFrameSkip = (i === 0);
            this.frameCount++;
            // Handle pause key
            if ((keyPausePressed) && (state.playing || state.paused))
                state.pause();
            else if (state.halted)
                state.halt();
            else if (state.gameOver) {
                // Disable timers
                if ((soundEnabled) && (!ufo.ufoAudioElement.paused))
                    ufo.ufoAudioElement.pause();
                clearInterval(fpsTimer);
                marching.stop();
                state.reset();
                state.gameOverDisplaying = true;
            }
            else if (state.invaded) {
                gun.render();
            }
            else if ((state.playing) && (!state.paused)) {
                gun.move();
                gun.render();
                bullet.move();
                bullet.render();
                invaders.moveAndRender();
                ufo.moveAndRender();
                if (typeof bomb !== "undefined")
                    bomb.moveAndRender();
                if (typeof missile !== "undefined")
                    missile.moveAndRender();
            }
            else if (state.nextLevel) {
                barriers.destroy();
                barriers = new Barriers();
                invaders = new Invaders();
                ufo = new Ufo();
                marching.start();
                gun.x = gun.min;
                gun.hasMoved = true;
                state.reset();
                state.playing = true;
            }
            if (state.gameOverDisplaying) {
                // Display Game Over Message
                gameOverMessage.render();
            }
        }
    }
    ///
    ////  END Main Loop
    /////


    /////
    ////   View Class - window positioning
    ///
    function View() {
        this.svgRatio = 224 / 240;
        this.windowWidth = window.innerWidth;
        this.windowHeight = window.innerHeight;
        this.midY = this.windowWidth / 2;
        this.windowRatio = this.windowWidth / this.windowHeight;
        this.isLandscape = this.windowRatio >= this.svgRatio;
    }

    View.prototype = {
        Resize: function () {
            this.windowWidth = window.innerWidth;
            this.windowHeight = window.innerHeight;
            this.midY = this.windowWidth / 2;
            this.windowRatio = (this.windowWidth / this.windowHeight);
            this.isLandscape = (this.windowRatio >= this.svgRatio);

            //Calculate SVG Offset
            if (this.isLandscape) {
                // if window is wider (offsetX because alignment==center)
                canvasWidth = Math.floor(this.windowRatio * 240);
                canvasHeight = 240;
                svgOffsetX = Math.floor((canvasWidth - 224) / 2); //centered horizontally
            }
            else {
                // window is taller (offset is always 0,0, because alignment==top center)
                canvasWidth = 224;
                canvasHeight = Math.floor(224 / this.windowRatio);
                svgOffsetX = 0;
            }
            // Move the Pause Button
            pauseButton.resize();
            playButton.resize();
            muteButton.resize();

            // Stretch the canvas to fill the window
            touchCanvas.element.width = canvasWidth;
            touchCanvas.element.height = canvasHeight;

            restorePositions();
        }
    };

    function debounceResizeEvent(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        // Prevent multiple calls in quick succession
        if ((typeof resizeTimer !== "undefined") && (resizeTimer)) {
            clearTimeout(resizeTimer);
        }
        resizeTimer = setTimeout(function () { view.Resize(); }, 100);
    }
    ///
    ////  END View Class
    /////

    /////
    ////   Pause Button
    ///
    function PauseButton() {
        this.element = $DOM("pauseButton");
        this.matrix = this.element.transform.baseVal.getItem(0).matrix;
        this.display = this.element.attributes.display;
        this.x = this.matrix.e;
        this.y = this.matrix.f;
    }

    PauseButton.prototype = {
        resize: function () {
            //Calculate SVG Offset
            if (view.isLandscape) {
                this.matrix.e = canvasWidth - 24 - svgOffsetX;
                this.matrix.f = 8;
            }
            else {
                this.matrix.e = svgOffsetX + 85;
                this.matrix.f = canvasHeight - 24;
            }
            this.x = this.matrix.e;
            this.y = this.matrix.f;
        },
        show: function () {
            this.display.value = "inline";
        },
        hide: function () {
            this.display.value = "none";
        },
        hitTest: function (x, y) {
            return ((y >= this.y) && (x >= this.x) && (y <= (this.y + 25)) && (x <= (this.x + 25)));
        }
    };
    ///
    ////  END Pause Button
    /////

 /////
 
    ////   Mute Button
    ///
    function MuteButton() {
        this.element = $DOM("muteButton");
        this.matrix = this.element.transform.baseVal.getItem(0).matrix;
        this.display = this.element.attributes.display;
        this.x = this.matrix.e;
        this.y = this.matrix.f;

    }
    
    MuteButton.prototype = {
		touchEnd: function () {
			mute.toggle();
		},
		resize: function () {
			//Calculate SVG Offset
			if (view.isLandscape) {
				this.matrix.e = canvasWidth - 24 - svgOffsetX;
				this.matrix.f = 38;
			}
			else {
				this.matrix.e = svgOffsetX + 115;
				this.matrix.f = canvasHeight - 24;
			}
			this.x = this.matrix.e;
			this.y = this.matrix.f;
        },
        show: function () {
            this.display.value = "inline";
        },
        hide: function () {
            this.display.value = "none";
        },
        hitTest: function (x, y) {
            return ((y >= this.y) && (x >= this.x) && (y <= (this.y + 25)) && (x <= (this.x + 25)));
        }
	}
    ///
    ////  END Pause Button
    /////

    /////
    ////   Play Button
    ///
    /// (Touch is handled by click event.)
    function PlayButton() {
        this.element = $DOM("playButton");
        this.matrix = this.element.transform.baseVal.getItem(0).matrix;
        this.display = this.element.attributes.display;
        this.x = this.matrix.e;
        this.y = this.matrix.f;
    }

    PlayButton.prototype = {
        resize: function () {
            //Calculate SVG Offset
            if (view.isLandscape) {
                this.matrix.e = canvasWidth - 24 - svgOffsetX;
                this.matrix.f = 8;
            }
            else {
                this.matrix.e = svgOffsetX + 85;
                this.matrix.f = canvasHeight - 24;
            }
            this.x = this.matrix.e;
            this.y = this.matrix.f;
        },
        show: function () {
            this.display.value = "inline";
        },
        hide: function () {
            this.display.value = "none";
        }
    };
    ///
    ////  END Play Button
    /////


    /////
    ////   Joystick Button
    ///
    function JoystickButton() {
        this.element = $DOM("joystickButton");
        this.matrix = this.element.transform.baseVal.getItem(0).matrix;
        this.display = this.element.attributes.display;
        this.x = this.matrix.e;
        this.y = this.matrix.f;
        this.id = -1;
    }

    JoystickButton.prototype = {
        show: function () {
            this.display.value = "inline";
        },
        hide: function () {
            this.display.value = "none";
        }
    };
    ///
    ////  END Joystick Button
    /////

    /////
    ////   Joystick
    ///
    function Joystick() {
        this.element = $DOM("joystick");
        this.joystickButtonPath = $DOM("joystickButtonPath");
        this.matrix = this.element.transform.baseVal.getItem(0).matrix;
        this.display = this.element.attributes.display;
        this.id = -1;
        this.button = new JoystickButton();
    }

    Joystick.prototype = {
        show: function () {
            this.display.value = "inline";
            this.button.show();
        },
        hide: function () {
            this.display.value = "none";
            this.button.hide();
        },
        move: function (x, y) {
            this.button.matrix.e = this.matrix.e = x;
            this.button.matrix.f = this.matrix.f = y;
            this.joystickButtonPath.attributes.fill.value = "#FFF";
        },
        touchEnd: function () {
            keyLeftPressed = false;
            keyRightPressed = false;
            this.id = -1;
            this.button.matrix.e = this.matrix.e;
            this.joystickButtonPath.attributes.fill.value = "#333";
        },
        moveButton: function (x) {
            this.button.matrix.e = x;
        }
    };
    ///
    ////  END Joystick
    /////


    /////
    ////   Fire Button
    ///
    function FireButton() {
        this.element = $DOM("fireButton");
        this.fireButtonPath = $DOM("fireButtonPath");
        this.matrix = this.element.transform.baseVal.getItem(0).matrix;
        this.display = this.element.attributes.display;
        this.x = this.matrix.e;
        this.y = this.matrix.f;
        this.id = -1;
    }

    FireButton.prototype = {
        show: function () {
            this.display.value = "inline";
        },
        hide: function () {
            this.display.value = "none";
        },
        move: function (x, y) {
            this.matrix.e = x;
            this.matrix.f = y;
            this.fireButtonPath.attributes.fill.value = "#FFF";
        },
        touchEnd: function () {
            this.id = -1;
            this.fireButtonPath.attributes.fill.value = "#ccc";
        }
    };
    ///
    ////  END Fire Button
    /////


    /////
    ////   Touch Control Event Handlers
    ///
    function restorePositions() {
        joystick.move(10 - svgOffsetX, canvasHeight - 35);
        fireButton.move(canvasWidth - 41 - svgOffsetX, canvasHeight - 41);
        fireButton.fireButtonPath.attributes.fill.value = "#333";
        joystick.joystickButtonPath.attributes.fill.value = "#333";
    }

    function TouchCanvas() {
        this.element = $DOM("touchCanvas");
        $DOM("touchCanvas").style.display = 'inline';
        this.element.addEventListener("touchstart", handleTouchStart, false);
        this.element.addEventListener("touchend", handleTouchEnd, false);
        this.element.addEventListener("touchcancel", handleTouchCancel, false);
        this.element.addEventListener("touchleave", handleTouchLeave, false);
        this.element.addEventListener("touchmove", handleTouchMove, false);
        if (helper.pointy) {
            
            // Disables menu
            this.element.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
        }
    }

    // Complicated because of three coordinate systems - canvas, SVG and page/window
    function handleTouchStart(evt) {
        evt.preventDefault();
        var touches = evt.changedTouches;
        if ((typeof touches) !== "undefined") {
            evt.stopPropagation();
            for (var i = 0; i < touches.length; i++) {
                var canvasX = ((canvasWidth / view.windowWidth) * touches[i].pageX) - svgOffsetX;
                var canvasY = (canvasHeight / view.windowHeight) * touches[i].pageY;
                if (pauseButton.hitTest(canvasX, canvasY)) {
                    keyPausePressed = true;
                    break;
                }
                else 
                    if (muteButton.hitTest(canvasX, canvasY)) {
						mute.toggle();
                    break;
					}
				
                else {
                    if ((touches[i].pageX < view.midY) && (joystick.id === -1)) {
                        // New joystick touch - reposition joystick
                        joystick.move(canvasX - 29, canvasY - 12);
                        joystick.id = touches[i].identifier;
                    }
                    else if ((touches[i].pageX > view.midY) && (fireButton.id === -1)) {
                        // New fire button touch - reposition fire button
                        fireButton.move(canvasX - 17, canvasY - 17);
                        fireButton.id = touches[i].identifier;
                        keyShootPressed = true;
                    }
                }
            }
            return false;
        }
    }

    

    function handleTouchEnd(evt) {
        evt.preventDefault();
        var touches = evt.changedTouches;
        if ((typeof touches) !== "undefined") {
            evt.stopPropagation();
            for (var i = 0; i < touches.length; i++) {
                if (touches[i].identifier === joystick.id) {
                    joystick.touchEnd();
                }
                else if (touches[i].identifier === fireButton.id) {
                    fireButton.touchEnd();
                }
            }
        }
    }

   

    function handleTouchCancel(evt) {
        evt.preventDefault();
        handleTouchEnd(evt);
    }

    function handleTouchLeave(evt) {
        evt.preventDefault();
        handleTouchEnd(evt);
    }

    //TODO: Improve efficiency - redraw less?
    function handleJoystickMove(x, y) {
        var oldX = joystick.matrix.e;
        keyLeftPressed = false;
        keyRightPressed = false;
        var newX = ((canvasWidth / view.windowWidth) * x) - svgOffsetX - 29;
        //if (newX < (oldX - 5)) {
        if (newX < oldX) {
            keyLeftPressed = true;
            if (newX < (oldX - 16)) {
                joystick.matrix.e -= ((oldX - 16) - newX);
            }
        }
        else if (newX > oldX) {
            keyRightPressed = true;
            if (newX > (oldX + 16)) {
                joystick.matrix.e += (newX - (oldX + 16));
            }
        }
        else {
            keyLeftPressed = false;
            keyRightPressed = false;
        }
        joystick.move(joystick.matrix.e, (canvasHeight / view.windowHeight) * y - 12);
        joystick.moveButton(newX);
    }

    function handleTouchMove(evt) {
        evt.preventDefault();
        var touches = evt.changedTouches;
        if ((typeof touches) !== "undefined") {
            for (var i = 0; i < touches.length; i++) {
                if (touches[i].identifier === joystick.id) {
                    handleJoystickMove(touches[i].pageX, touches[i].pageY);
                    break;
                }
            }
        }
    }

    ///
    ////  END Touch Control Event Handlers
    /////

    // One-off initialisation of elements prior to starting game.
    function InitialiseSvgDocument() {
        // Initialise SVG Element Variables
        titleSvgDocument = $DOM("TitleSvg");
        backSvgDocument = $DOM("BackSVG");
        bombGroupElement = $SVG("bombGroup");
        availableBombs.push($SVG("bomb1Element"));
        availableBombs.push($SVG("bomb2Element"));
        bulletExplodeElement = $SVG("bulletExplode");
        // Handle Touch Device Vertical Offset (make more room for touch controls)
        if (helper.touch) {
            svgDocument.preserveAspectRatio.baseVal.align = svgDocument.preserveAspectRatio.baseVal.SVG_PRESERVEASPECTRATIO_XMIDYMIN;
            backSvgDocument.preserveAspectRatio.baseVal.align = backSvgDocument.preserveAspectRatio.baseVal.SVG_PRESERVEASPECTRATIO_XMIDYMIN;
            titleSvgDocument.preserveAspectRatio.baseVal.align = backSvgDocument.preserveAspectRatio.baseVal.SVG_PRESERVEASPECTRATIO_XMIDYMIN;
        }
        // Create Dynamic Invader SVG Elements (just once - hence here)
        var invaderGroup = $SVG("invaderGroup");
        invaderElemArray = [];     // array of invader elements, indexed by position
        for (var row = 0; row < 5; row++) {
            for (var column = 0; column < 11; column++) {
                var position = (row * 11) + column;
                // Create the Sprite A invaders
                var invader = document.createElementNS(svgns, "rect");
                invader.setAttributeNS(null, "id", "invader" + position);
                invader.setAttributeNS(null, "display", "none");
                invader.setAttributeNS(null, "transform", "matrix(1 0 0 1 " + ((column * 16) + 26).toString() + " " + (120 - (row * 16)).toString() + ")");
                invader.setAttributeNS(null, "width", "12");
                invader.setAttributeNS(null, "height", "8");
                invader.setAttributeNS(null, "fill", invaderFill[row]);
                invader.setAttributeNS(null, "clip-path", "url(#C" + (Math.floor(row / 2)).toString() + "A)");
                invader.setAttributeNS(null, "stroke", "none");
                invaderElemArray.push(invader);
                invaderGroup.appendChild(invader);
            }
        }
        // Keyboard event handlers
        document.addEventListener("keydown", KeyDown, true);
        document.addEventListener("keyup", KeyUp, true);
        document.addEventListener("keypress", KeyPress, false);
        // Touch Objects
        if (helper.touch) {
            touchCanvas = new TouchCanvas();
            pauseButton = new PauseButton();
            playButton = new PlayButton();
            joystick = new Joystick();
            fireButton = new FireButton();
            muteButton = new MuteButton();
            window.addEventListener("resize", debounceResizeEvent, false);
        }
    }

    ///// 
    ////  TitleScreen: Handles Panel Hiding
    ///

    function TitleScreen() {
        this.aboutPanel = $DOM("aboutPanel");
        this.controlsPanel = $DOM("controlsPanel");
    }

    TitleScreen.prototype = {
        controlsclick: function () {
            this.aboutPanel.attributes.display.value = "none";
            this.controlsPanel.attributes.display.value = "inline";
            return false;
        },
        aboutclick: function () {
            this.aboutPanel.attributes.display.value = "inline";
            this.controlsPanel.attributes.display.value = "none";
            return false;
        }
    };

    ///// 
    ////  Modernizr SVG handling and Starting Game
    ///   Equivalent to JQuery's document ready function: $(function () {});
    //
    ready(function () {
        document.title = "Space InVectors";
        // Initialise Helpers
        window.$DOM = helper.DOM;
        svgDocument = $DOM("InVectors");
        window.$SVG = helper.SVG;
        if (Modernizr.svg) {
            /* properties for browsers that support svg */
            $DOM("invadersBody").style.background = "url(Images/texture2.png) repeat";
            $DOM("waitDiv").style.display = 'none';
            $DOM("svgDiv").style.display = 'inline';
            $DOM("sorry").style.display = 'none';
            InitialiseSvgDocument();
            titleScreen = new TitleScreen();
            // Register click events
            $DOM("playlink").addEventListener("click", function () { state.pause(); }, false);
            $DOM("controlslink").addEventListener("click", function () { titleScreen.controlsclick(); }, false);
            $DOM("aboutlink").addEventListener("click", function () { titleScreen.aboutclick(); }, false);
            $DOM("playButton").addEventListener("click", function () { state.pause(); }, false);
            $DOM("muteButton").addEventListener("click", function () { mute.toggle(); }, false);
            $DOM("bkeylink").addEventListener("click", function () { background.toggle(); }, false);
            $DOM("mkeylink").addEventListener("click", function () { mute.toggle(); }, false);
            $DOM("mkeylinkpause").addEventListener("click", function () { mute.toggle(); }, false);
            $DOM("pkeylink").addEventListener("click", function () { state.pause(); }, false);
            StartGame();
        }
        else {
            /* properties for browsers that do not support svg */
            $DOM("waitDiv").style.display = 'none';
            $DOM("svgDiv").style.display = 'none';
            $DOM("sorry").style.display = 'inline';
        }
    });

})();
